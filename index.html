<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Black Clover – Licht Boss Fight</title>
<style>
body { margin: 0; background: #000; overflow: hidden; font-family: Arial, sans-serif; }
canvas { display: block; margin: auto; background: #000; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
canvas.width = 1280;
canvas.height = 720;

const keys = {};
const mouse = { x: 0, y: 0, down: false, prev: false };

window.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();
  keys[key] = true;
  
  // Queue Yami's Q ability directly from keydown event
  if (player && player.type === "yami" && key === 'q' && player.specialCooldown === 0) {
    console.log("Queueing Yami Q ability!");
    queuedYamiQ = true;
  }
  
  if (key === "escape") keys.escape = true;
  if (key === "backspace") keys.backspace = true;
});
window.addEventListener("keyup", e => {
  const key = e.key.toLowerCase();
  keys[key] = false;
  if (key === "escape") keys.escape = false;
  if (key === "backspace") keys.backspace = false;
});
canvas.addEventListener("mousemove", e => {
  const r = canvas.getBoundingClientRect();
  mouse.x = e.clientX - r.left;
  mouse.y = e.clientY - r.top;
});
canvas.addEventListener("mousedown", () => mouse.down = true);
canvas.addEventListener("mouseup", () => mouse.down = false);

const IMG = {};
const files = {
  asta_idle: "asta_idle.png", 
  asta_attack: "asta_attack.png",
  noelle_idle: "noelle_idle.png", 
  noelle_attack: "noelle_attack.png",
  licht_idle: "licht_idle.png",
  licht_attack: "licht_attack.png",
  licht_clone: "licht_clone.png",
  bg: "clover_castle.png"
};

let loaded = 0;
const total = Object.keys(files).length;
for (const k in files) {
  const img = new Image();
  img.onload = () => {
    loaded++;
    console.log("✅ Loaded: " + k);
  };
  img.onerror = () => {
    loaded++;
    console.error("❌ Failed to load: " + k + " - Check filename!");
  };
  img.src = files[k];
  IMG[k] = img;
}

let state = "title";
let menuState = "main";
let selected = 0;
let hitStop = 0;
let shake = 0;
let phase = 1;
let combo = 0;
let comboTime = 0;
let cam = 0;
let player = null;
let boss = null;
let enterPrev = false;

const stats = {
  wins: 0,
  losses: 0,
  astaPlays: 0,
  noellePlays: 0,
  luckPlays: 0,
  yamiPlays: 0
};

const achievements = {
  winAsta: false,
  winNoelle: false,
  winLuck: false,
  viewCredits: false,
  winLowHp: false,
  winNoHit: false,
  useTransform: false,
  win10: false,
  win25: false,
  win50: false
};

const achievementList = [
  { id: "winAsta", name: "Asta's Victory", desc: "Win with Asta" },
  { id: "winNoelle", name: "Noelle's Victory", desc: "Win with Noelle" },
  { id: "winLuck", name: "Luck's Victory", desc: "Win with Luck" },
  { id: "viewCredits", name: "Credits Viewer", desc: "View the credits" },
  { id: "winLowHp", name: "Close Call", desc: "Win with ≤10 HP" },
  { id: "winNoHit", name: "Flawless Victory", desc: "Win without being hit" },
  { id: "useTransform", name: "Transformation", desc: "Use any transformation" },
  { id: "win10", name: "Veteran", desc: "Get 10 wins" },
  { id: "win25", name: "Dark Magic Unlock", desc: "Get 25 wins - Unlocks Yami" },
  { id: "win50", name: "Legend", desc: "Get 50 wins" }
];

let wasHit = false;
let achievementPopups = [];
let invertScreen = 0;
let blackHoles = [];
let cheatMenuOpen = false;
let queuedYamiQ = false;

function unlockAchievement(id) {
  if (!achievements[id]) {
    achievements[id] = true;
    const ach = achievementList.find(a => a.id === id);
    if (ach) {
      achievementPopups.push({
        name: ach.name,
        desc: ach.desc,
        time: 300,
        y: -100
      });
    }
  }
}

const proj = [];
const clones = [];
const part = [];
const dragons = [];
const homingProj = [];
const lightningPulses = [];

const chars = [
  { id: "asta", name: "ASTA", col: "#0f0", info: "Anti-Magic" },
  { id: "noelle", name: "NOELLE", col: "#4af", info: "Water Magic" },
  { id: "luck", name: "LUCK", col: "#0ff", info: "Lightning Magic" },
  { id: "yami", name: "YAMI", col: "#000", info: "Dark Magic", locked: true }
];

const plat = [
  { x: -700, y: 620, w: 2800, h: 120, c: "#2a4" },
  { x: 300, y: 480, w: 240, h: 20, c: "#4a6" },
  { x: 740, y: 420, w: 240, h: 20, c: "#4a6" },
  { x: 480, y: 300, w: 220, h: 20, c: "#4a6" }
];

function addPart(x, y, col, n) {
  for (let i = 0; i < n; i++) {
    part.push({ x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8, t: 40, s: 3 + Math.random() * 5, c: col });
  }
}

function updPart() {
  for (let i = part.length - 1; i >= 0; i--) {
    const p = part[i];
    p.x += p.vx; p.y += p.vy; p.vx *= 0.95; p.vy *= 0.95;
    if (--p.t <= 0) part.splice(i, 1);
  }
}

function drawPart() {
  part.forEach(p => {
    ctx.globalAlpha = p.t / 40;
    
    // Draw outline if particle has one
    if (p.outline) {
      ctx.strokeStyle = p.outline;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.s, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    ctx.fillStyle = p.c;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.s, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
}

function updateAchievementPopups() {
  for (let i = achievementPopups.length - 1; i >= 0; i--) {
    const popup = achievementPopups[i];
    popup.time--;
    
    // Slide in animation
    if (popup.y < 20) {
      popup.y += 3;
    }
    
    if (popup.time <= 0) {
      achievementPopups.splice(i, 1);
    }
  }
}

function drawAchievementPopups() {
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  
  achievementPopups.forEach((popup, index) => {
    const x = 950;
    const y = popup.y + (index * 90);
    
    // Background
    ctx.fillStyle = "rgba(0,0,0,0.9)";
    ctx.fillRect(x, y, 310, 80);
    
    // Border with glow
    ctx.strokeStyle = "#fd7";
    ctx.lineWidth = 3;
    ctx.shadowBlur = 15;
    ctx.shadowColor = "#fd7";
    ctx.strokeRect(x, y, 310, 80);
    ctx.shadowBlur = 0;
    
    // Achievement Unlocked text
    ctx.fillStyle = "#fd7";
    ctx.font = "bold 16px Arial";
    ctx.fillText("ACHIEVEMENT UNLOCKED!", x + 10, y + 25);
    
    // Achievement name
    ctx.fillStyle = "#fff";
    ctx.font = "bold 20px Arial";
    ctx.fillText(popup.name, x + 10, y + 50);
    
    // Achievement description
    ctx.fillStyle = "#aaa";
    ctx.font = "14px Arial";
    ctx.fillText(popup.desc, x + 10, y + 68);
    
    // Checkmark
    ctx.fillStyle = "#0f0";
    ctx.font = "bold 30px Arial";
    ctx.fillText("✓", x + 270, y + 50);
  });
  
  ctx.restore();
}

class Player {
  constructor(ch) {
    this.type = ch.id; this.col = ch.col;
    this.x = 200; this.y = 500; this.vx = 0; this.vy = 0;
    this.w = 48; this.h = 64; this.dir = 1; this.ground = false;
    this.dash = 0; this.dashCooldown = 0; this.dashCount = 0;
    this.hp = ch.id === "noelle" ? 200 : (ch.id === "yami" ? 150 : 100);
    this.maxhp = ch.id === "noelle" ? 200 : (ch.id === "yami" ? 150 : 100);
    this.cool = 0; this.inv = 0; this.flash = 0;
    this.specialCooldown = 0;
    this.demonSlash = 0;
    this.shieldActive = 0;
    this.shieldCooldown = 0;
    this.shieldAngle = 0;
    this.transformMeter = 0;
    this.transformed = false;
    this.transformTime = 0;
    this.transformUsed = false;
    this.doubleJumped = false;
    this.luckOrbPairs = 0;
    this.luckOrbTimer = 0;
    this.luckDashPhase = 0;
    this.blackHoleActive = 0;
  }

  upd() {
    // Check Yami Q FIRST, before ANY returns
    if (this.type === "yami" && queuedYamiQ) {
      console.log("=== EXECUTING YAMI Q ===");
      queuedYamiQ = false;
      this.specialCooldown = 480;
      invertScreen = 15;
      
      // Kill all clones
      console.log("Total clones:", clones.length);
      let clonesKilled = 0;
      clones.forEach(c => {
        if (c.hp > 0) {
          c.hp = 0;
          addPart(c.x, c.y, "#000", 25);
          combo++;
          comboTime = 120;
          clonesKilled++;
        }
      });
      
      console.log("Clones killed:", clonesKilled);
      
      // Damage boss
      if (boss) {
        console.log("Boss HP before:", boss.hp);
        boss.hp -= 125;
        boss.flash = 10;
        combo++;
        comboTime = 120;
        shake = 15;
        addPart(boss.x, boss.y, "#000", 30);
        console.log("Boss HP after:", boss.hp);
      }
      
      // Visual effects
      for (let i = 0; i < 20; i++) {
        const angle = (Math.PI * 2 * i) / 20;
        const dist = 200;
        addPart(
          640 + Math.cos(angle) * dist,
          360 + Math.sin(angle) * dist,
          "#000",
          10
        );
      }
      console.log("=== YAMI Q COMPLETE ===");
    }
    
    if (this.hp <= 0) { 
      state = "lose"; 
      stats.losses++;
      return; 
    }
    if (this.inv > 0) this.inv--;
    if (this.flash > 0) this.flash--;
    if (this.dashCooldown > 0) this.dashCooldown--;
    if (this.specialCooldown > 0) this.specialCooldown--;
    if (this.shieldCooldown > 0) this.shieldCooldown--;
    if (this.luckOrbTimer > 0) this.luckOrbTimer--;
    if (this.blackHoleActive > 0) this.blackHoleActive--;
    
    if (this.luckDashPhase > 0) {
      this.luckDashPhase--;
      this.inv = 999;
      
      if (this.luckDashPhase === 60 || this.luckDashPhase === 30) {
        if (boss) {
          const dx = boss.x - this.x;
          const dy = boss.y - this.y;
          const dist = Math.hypot(dx, dy);
          this.x = boss.x;
          this.y = boss.y;
          boss.hp -= 18;
          boss.flash = 5;
          combo++;
          comboTime = 120;
          shake = 8;
          addPart(boss.x, boss.y, "#0ff", 20);
          this.transformMeter = Math.min(600, this.transformMeter + 18);
        }
      }
      
      if (this.luckDashPhase === 45 || this.luckDashPhase === 15) {
        this.x = 200;
        this.y = 500;
      }
      
      if (this.luckDashPhase === 0) {
        this.shieldCooldown = 300;
      }
      
      keys.ePrev = keys.e;
      keys.rPrev = keys.r;
      keys.qPrev = keys.q;
      return;
    }
    
    if (this.transformed && this.transformTime > 0) {
      this.transformTime--;
      if (this.transformTime <= 0) {
        this.transformed = false;
      }
    }
    
    // Transformation activation (R key)
    if (keys.r && !keys.rPrev && this.transformMeter >= 600 && !this.transformUsed) {
      this.transformed = true;
      this.transformTime = 1800;
      this.transformUsed = true;
      this.transformMeter = 600;
      unlockAchievement("useTransform");
      
      if (this.type === "asta") {
        for (let i = proj.length - 1; i >= 0; i--) {
          if (proj[i].own === "e") {
            addPart(proj[i].x, proj[i].y, "#f00", 10);
            proj.splice(i, 1);
          }
        }
        
        clones.forEach(c => {
          if (c.hp > 0) {
            c.hp = 0;
            addPart(c.x, c.y, "#f00", 25);
            combo++;
            comboTime = 120;
          }
        });
        
        for (let i = 0; i < 50; i++) {
          const angle = (Math.PI * 2 * i) / 50;
          const dist = 150;
          addPart(
            this.x + 24 + Math.cos(angle) * dist,
            this.y + 32 + Math.sin(angle) * dist,
            i % 2 === 0 ? "#000" : "#f00",
            8
          );
        }
        shake = 15;
      } else {
        addPart(this.x + 24, this.y + 32, "#4af", 30);
        shake = 8;
      }
    }

    if (this.onGround) this.doubleJumped = false;

    if (this.type === "noelle") {
      if (keys.e && this.shieldCooldown === 0) {
        this.shieldActive = 999;
        this.inv = 999;
        this.shieldAngle += 0.1;
        if (keys.a) { this.vx = -2; this.dir = -1; }
        else if (keys.d) { this.vx = 2; this.dir = 1; }
        else this.vx *= 0.9;
      } else if (this.shieldActive > 0 && !keys.e) {
        this.shieldActive = 0;
        this.shieldCooldown = 480;
      }
    } else if (this.type === "yami") {
      if (keys.e && !keys.ePrev && this.shieldCooldown === 0) {
        this.blackHoleActive = 360;
        this.shieldCooldown = 360;
        blackHoles.push(new BlackHole(this.x + 24, this.y - 40));
        addPart(this.x + 24, this.y - 40, "#000", 20);
      }
    } else if (this.type === "luck") {
      if (keys.e && !keys.ePrev && this.shieldCooldown === 0) {
        this.luckDashPhase = 75;
        addPart(this.x + 24, this.y + 32, "#0ff", 20);
      }
    } else if (this.type === "asta") {
      if (keys.e && !keys.ePrev && this.shieldCooldown === 0) {
        this.shieldActive = 0;
        this.shieldCooldown = 420;
        
        for (let i = 0; i < 4; i++) {
          setTimeout(() => {
            const angle = (Math.PI * 2 * i / 4);
            homingProj.push(new HomingProjectile(this.x + 24, this.y + 32, angle, this.transformed));
            addPart(this.x + 24, this.y + 32, "#000", 10);
            addPart(this.x + 24, this.y + 32, "#f00", 8);
          }, i * 100);
        }
      }
      
      if (this.shieldActive > 0) {
        this.shieldActive--;
        this.shieldAngle += 0.15;
      }
    }

    if (this.demonSlash > 0) {
      this.demonSlash--;
      this.inv = 999;
      if (Math.random() < 0.5) {
        addPart(this.x + 24, this.y + 32, "#000", 3);
        addPart(this.x + 24, this.y + 32, "#f00", 2);
      }
      this.x += this.vx;
      this.y += this.vy;
      
      const damage = this.transformed ? 63 : 60;
      if (boss && Math.abs(this.x - boss.x) < 70 && Math.abs(this.y - boss.y) < 70) {
        if (!this.demonSlashHitBoss) {
          boss.hp -= damage;
          boss.flash = 5;
          combo++;
          comboTime = 120;
          shake = 8;
          addPart(boss.x, boss.y, "#ff0", 20);
          this.demonSlashHitBoss = true;
          this.transformMeter = Math.min(600, this.transformMeter + damage);
        }
      }
      
      clones.forEach(c => {
        if (c.hp > 0 && Math.abs(this.x - c.x) < 70 && Math.abs(this.y - c.y) < 70) {
          if (!c.hitByDemonSlash) {
            c.hp -= damage;
            combo++;
            comboTime = 120;
            addPart(c.x, c.y, "#f0f", 15);
            c.hitByDemonSlash = true;
            this.transformMeter = Math.min(600, this.transformMeter + damage);
            setTimeout(() => c.hitByDemonSlash = false, 100);
          }
        }
      });
      
      keys.ePrev = keys.e;
      keys.rPrev = keys.r;
      keys.qPrev = keys.q;
      return;
    }

    if (!(this.type === "noelle" && this.shieldActive > 0)) {
      if (this.dash > 0) {
        this.dash--; this.inv = this.dash;
      } else {
        let speedMult = 1;
        if (this.type === "noelle" && this.transformed) speedMult = 1.03;
        if (this.type === "luck" && this.transformed) speedMult = 1.05;
        if (keys.a) { this.vx = -5 * speedMult; this.dir = -1; }
        else if (keys.d) { this.vx = 5 * speedMult; this.dir = 1; }
        else this.vx *= 0.85;
      }
    }

    if (this.onGround && keys[" "]) { 
      this.vy = -16; 
      this.onGround = false; 
      addPart(this.x + 24, this.y + 64, "#888", 5); 
    } else if (!this.onGround && keys[" "] && !keys.spacePrev && this.type === "noelle" && this.transformed && !this.doubleJumped) {
      this.vy = -16;
      this.doubleJumped = true;
      // Double jump particles underneath
      for (let i = 0; i < 15; i++) {
        part.push({
          x: this.x + 24,
          y: this.y + 64,
          vx: (Math.random() - 0.5) * 6,
          vy: Math.random() * 4,
          t: 30,
          s: 4 + Math.random() * 4,
          c: "#4af"
        });
      }
    }
    
    if (keys.shift && this.dash === 0 && this.dashCooldown === 0 && this.onGround) {
      if (this.type === "luck" && this.transformed) {
        this.dash = 12;
        this.dashCount++;
        if (this.dashCount >= 2) {
          this.dashCooldown = 300;
          this.dashCount = 0;
        }
        this.vx = this.dir * 18;
        addPart(this.x + 24, this.y + 32, this.col, 15);
      } else {
        this.dash = 12;
        this.dashCooldown = 300;
        this.vx = this.dir * 18;
        addPart(this.x + 24, this.y + 32, this.col, 15);
      }
    }
    
    if (this.type === "luck" && this.onGround && this.dashCount > 0 && this.dash === 0) {
      if (!this.transformed) {
        this.dashCooldown = 300;
        this.dashCount = 0;
      }
    }

    if (keys.q && this.specialCooldown === 0) {
      if (this.type === "asta") {
        const dx = mouse.x + cam - (this.x + 24);
        const dy = mouse.y - (this.y + 32);
        const angle = Math.atan2(dy, dx);
        this.vx = Math.cos(angle) * 25;
        this.vy = Math.sin(angle) * 25;
        this.demonSlash = 30;
        this.demonSlashHitBoss = false;
        this.specialCooldown = 300;
        addPart(this.x + 24, this.y + 32, "#000", 20);
        addPart(this.x + 24, this.y + 32, "#f00", 15);
      } else if (this.type === "noelle" && this.shieldActive === 0) {
        dragons.push(new SeaDragon(this.x + 24, this.y + 32, this.transformed));
        this.specialCooldown = 600;
        addPart(this.x + 24, this.y + 32, "#4af", 30);
      }
    }

    this.vy += 0.8; this.x += this.vx; this.y += this.vy;

    this.onGround = false;
    plat.forEach(p => {
      if (this.x + this.w > p.x && this.x < p.x + p.w && this.y + this.h > p.y && this.y + this.h - this.vy < p.y + 10) {
        this.y = p.y - this.h; this.vy = 0; this.onGround = true;
      }
    });

    if (mouse.down && !mouse.prev && this.cool === 0) {
      if (this.type === "noelle" && this.shieldActive > 0) {
      } else {
        if (this.type === "noelle") this.cool = 90;
        else if (this.type === "luck") {
          this.cool = 72;
          const a = Math.atan2(mouse.y - (this.y + 32), mouse.x + cam - (this.x + 24));
          proj.push(new Proj(this.x + 24, this.y + 32, a, this.type, this.col, this.transformed));
          setTimeout(() => {
            if (player && player.type === "luck") {
              const a2 = Math.atan2(mouse.y - (player.y + 32), mouse.x + cam - (player.x + 24));
              proj.push(new Proj(player.x + 24, player.y + 32, a2, player.type, player.col, player.transformed));
              addPart(player.x + 24, player.y + 32, player.col, 8);
            }
          }, 100);
        } else if (this.type === "yami") {
          this.cool = 150;
        } else {
          this.cool = 120;
        }
        
        if (this.type !== "luck") {
          const a = Math.atan2(mouse.y - (this.y + 32), mouse.x + cam - (this.x + 24));
          proj.push(new Proj(this.x + 24, this.y + 32, a, this.type, this.col, this.transformed));
        }
        addPart(this.x + 24, this.y + 32, this.col, 8);
      }
    }
    if (this.cool > 0) this.cool--;
    if (comboTime > 0) comboTime--; else combo = 0;
    
    keys.ePrev = keys.e;
    keys.rPrev = keys.r;
    keys.spacePrev = keys[" "];
    keys.tPrev = keys.t;
    keys.qPrev = keys.q;
  }

  dmg(n) {
    if (this.inv > 0) return;
    this.hp -= n; this.inv = 30; this.flash = 10; shake = 10;
    addPart(this.x + 24, this.y + 32, "#f00", 20);
    if (this.hp < 0) this.hp = 0;
    wasHit = true;
  }

  draw() {
    let spr;
    const attacking = this.cool > 0 && this.cool > 5;
    
    if (this.type === "asta") {
      spr = attacking ? IMG.asta_attack : IMG.asta_idle;
    } else {
      spr = attacking ? IMG.noelle_attack : IMG.noelle_idle;
    }
    
    ctx.save();
    ctx.translate(this.x + 24, this.y + 32);
    
    if (this.flash > 0 && Math.floor(this.flash / 2) % 2 === 0) {
      ctx.globalAlpha = 0.5; ctx.fillStyle = "#fff"; ctx.fillRect(-24, -32, 48, 64); ctx.globalAlpha = 1;
    }
    
    if (spr.complete && spr.width > 0) {
      ctx.scale(this.dir, 1); ctx.drawImage(spr, -24, -32, 48, 64);
    } else {
      ctx.fillStyle = this.type === "asta" ? "#000" : this.col;
      ctx.scale(this.dir, 1); ctx.fillRect(-24, -32, 48, 64);
      ctx.fillStyle = this.type === "asta" ? "#fff" : "#000";
      ctx.fillRect(-14, -17, 8, 8);
    }
    
    if (this.dash > 0) {
      ctx.shadowBlur = 20; ctx.shadowColor = this.col; ctx.globalAlpha = 0.3;
      ctx.fillStyle = this.col; ctx.fillRect(-24, -32, 48, 64);
      ctx.shadowBlur = 0; ctx.globalAlpha = 1;
    }
    
    ctx.restore();
    
    // Transformation visual effect with particles
    if (this.transformed) {
      if (this.type === "asta") {
        // Black particles with red outline
        if (Math.random() < 0.15) {
          const angle = Math.random() * Math.PI * 2;
          const dist = 30 + Math.random() * 15;
          const px = this.x + 24 + Math.cos(angle) * dist;
          const py = this.y + 32 + Math.sin(angle) * dist;
          part.push({
            x: px,
            y: py,
            vx: Math.cos(angle) * -2,
            vy: Math.sin(angle) * -2 - 1,
            t: 25,
            s: 3 + Math.random() * 3,
            c: "#000",
            outline: "#f00"
          });
        }
      } else if (this.type === "noelle") {
        // Light blue particles with white outline
        if (Math.random() < 0.15) {
          const angle = Math.random() * Math.PI * 2;
          const dist = 30 + Math.random() * 15;
          const px = this.x + 24 + Math.cos(angle) * dist;
          const py = this.y + 32 + Math.sin(angle) * dist;
          part.push({
            x: px,
            y: py,
            vx: Math.cos(angle) * -2,
            vy: Math.sin(angle) * -2 - 1,
            t: 25,
            s: 3 + Math.random() * 3,
            c: "#4af",
            outline: "#fff"
          });
        }
      } else if (this.type === "luck") {
        // Cyan/neon blue particles
        if (Math.random() < 0.15) {
          const angle = Math.random() * Math.PI * 2;
          const dist = 30 + Math.random() * 15;
          const px = this.x + 24 + Math.cos(angle) * dist;
          const py = this.y + 32 + Math.sin(angle) * dist;
          part.push({
            x: px,
            y: py,
            vx: Math.cos(angle) * -2,
            vy: Math.sin(angle) * -2 - 1,
            t: 25,
            s: 3 + Math.random() * 3,
            c: "#0ff",
            outline: "#fff"
          });
        }
      }
    }
    
    if (this.shieldActive > 0 && this.type === "noelle") {
      ctx.save();
      ctx.translate(this.x + 24, this.y + 32);
      
      ctx.strokeStyle = "#4af";
      ctx.lineWidth = 5;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(0, 0, 65, 0, Math.PI * 2);
      ctx.stroke();
      
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.arc(0, 0, 50 - i * 12, this.shieldAngle + i * Math.PI / 4, this.shieldAngle + i * Math.PI / 4 + Math.PI);
        ctx.stroke();
      }
      
      ctx.shadowBlur = 35;
      ctx.shadowColor = "#4af";
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = "#4af";
      ctx.beginPath();
      ctx.arc(0, 0, 65, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    
    ctx.fillStyle = "#000"; ctx.fillRect(this.x - 5, this.y - 15, 58, 8);
    ctx.fillStyle = "#f00"; ctx.fillRect(this.x - 3, this.y - 13, 54 * (this.hp / this.maxhp), 4);
  }
}

class Proj {
  constructor(x, y, a, t, c, transformed, isOrb) {
    this.x = x; this.y = y; this.vx = Math.cos(a) * 12; this.vy = Math.sin(a) * 12;
    this.t = 100; this.own = t === "licht" ? "e" : "p"; this.col = c; this.type = t;
    this.angle = a;
    this.transformed = transformed || false;
    this.isOrb = isOrb || false;
  }

  upd() {
    this.x += this.vx; this.y += this.vy; this.t--;

    if (this.own === "p" && boss) {
      if (this.x > boss.x - 40 && this.x < boss.x + 40 && this.y > boss.y - 60 && this.y < boss.y + 40) {
        let damage = 20;
        if (this.type === "yami") damage = 45;
        if (this.isOrb) damage = 5;
        if (this.type === "asta" && this.transformed) damage = 21;
        if (this.type === "noelle" && this.transformed) damage = 20.4;
        boss.hp -= damage;
        boss.flash = 5;
        this.t = 0;
        combo++;
        comboTime = 120;
        shake = 5;
        addPart(this.x, this.y, "#ff0", 15);
        if (player) player.transformMeter = Math.min(600, player.transformMeter + damage);
      }
    }

    if (this.own === "p") {
      clones.forEach(c => {
        if (c.hp > 0 && Math.abs(this.x - c.x) < 25 && Math.abs(this.y - c.y) < 25) {
          let damage = 20;
          if (this.type === "yami") damage = 45;
          if (this.isOrb) damage = 5;
          if (this.type === "asta" && this.transformed) damage = 21;
          if (this.type === "noelle" && this.transformed) damage = 20.4;
          c.hp -= damage;
          this.t = 0;
          combo++;
          comboTime = 120;
          addPart(this.x, this.y, "#f0f", 12);
          if (player) player.transformMeter = Math.min(600, player.transformMeter + damage);
        }
      });
    }

    if (this.own === "e" && player && player.inv === 0) {
      // Check if absorbed by black hole
      let absorbed = false;
      blackHoles.forEach(bh => {
        if (bh.active && Math.hypot(this.x - bh.x, this.y - bh.y) < 100) {
          absorbed = true;
          this.t = 0;
        }
      });
      
      if (!absorbed && this.x > player.x - 10 && this.x < player.x + player.w + 10 && this.y > player.y - 10 && this.y < player.y + player.h + 10) {
        player.dmg(15);
        this.t = 0;
      }
    }
  }

  draw() {
    ctx.save(); ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.shadowBlur = 15; ctx.shadowColor = this.col;
    
    if (this.type === "asta") {
      ctx.fillStyle = "#000";
      ctx.fillRect(-30, -4, 60, 8);
      ctx.fillStyle = "#333";
      ctx.fillRect(-30, -2, 60, 4);
    } else if (this.type === "noelle") {
      const spr = IMG.noelle_attack;
      if (spr.complete && spr.width > 0) {
        ctx.drawImage(spr, -25, -25, 50, 50);
      } else {
        ctx.fillStyle = this.col;
        ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI * 2); ctx.fill();
      }
    } else if (this.type === "luck") {
      if (this.isOrb) {
        ctx.fillStyle = this.col;
        ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill();
      } else {
        ctx.fillStyle = this.col;
        ctx.fillRect(-25, -4, 50, 8);
      }
    } else if (this.type === "yami") {
      ctx.fillStyle = "#000";
      ctx.fillRect(-30, -5, 60, 10);
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 2;
      ctx.strokeRect(-30, -5, 60, 10);
    } else {
      const spr = IMG.licht_attack;
      if (spr.complete && spr.width > 0) {
        ctx.drawImage(spr, -15, -15, 30, 30);
      } else {
        ctx.fillStyle = this.col;
        ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI * 2); ctx.fill();
      }
    }
    
    ctx.shadowBlur = 0; ctx.restore();
  }
}

class Boss {
  constructor() {
    this.x = 900; this.y = 260; this.tx = 900; this.ty = 260;
    this.hp = 800; this.maxhp = 800; this.phase = 1;
    this.timer = 90; this.pattern = 0; this.flash = 0;
    this.stunned = 0;
  }

  upd() {
    if (this.hp <= 0) { 
      state = "win"; 
      stats.wins++;
      
      // Achievement checks
      if (player) {
        if (player.type === "asta") unlockAchievement("winAsta");
        if (player.type === "noelle") unlockAchievement("winNoelle");
        if (player.type === "luck") unlockAchievement("winLuck");
        if (player.hp <= 10) unlockAchievement("winLowHp");
        if (!wasHit) unlockAchievement("winNoHit");
      }
      
      if (stats.wins >= 10) unlockAchievement("win10");
      if (stats.wins >= 25) unlockAchievement("win25");
      if (stats.wins >= 50) unlockAchievement("win50");
      
      return; 
    }
    if (this.hp < 533) this.phase = 2;
    if (this.hp < 266) this.phase = 3;
    phase = Math.max(phase, this.phase);
    if (this.flash > 0) this.flash--;
    if (this.stunned > 0) {
      this.stunned--;
      return;
    }

    this.timer--;
    if (this.timer <= 0) {
      const pts = [{ x: 640, y: 260 }, { x: 420, y: 340 }, { x: 860, y: 340 }, { x: 640, y: 180 }, { x: 500, y: 240 }, { x: 780, y: 240 }];
      const p = pts[Math.floor(Math.random() * pts.length)];
      this.tx = p.x; this.ty = p.y;
      this.attack();
      this.timer = 90 - (this.phase * 10);
    }

    this.x += (this.tx - this.x) * 0.05;
    this.y += (this.ty - this.y) * 0.05;
  }

  attack() {
    this.pattern = (this.pattern + 1) % 3;
    if (this.pattern === 0) {
      this.fire();
      if (this.phase >= 2) setTimeout(() => boss && this.fire(), 300);
    } else if (this.pattern === 1) {
      for (let i = -1; i <= 1; i++) this.fireAngle(i * 0.3);
    } else {
      this.rain();
      if (this.phase >= 3) setTimeout(() => this.rain(), 500);
    }
    if (this.phase === 3 && clones.filter(c => c.hp > 0).length < 4) {
      clones.push(new Clone(this.x, this.y));
      clones.push(new Clone(this.x, this.y));
    }
    addPart(this.x, this.y, "#80f", 12);
  }

  fire() {
    if (!player) return;
    const a = Math.atan2(player.y - this.y, player.x - this.x);
    proj.push(new Proj(this.x, this.y, a, "licht", "#f80"));
  }

  fireAngle(off) {
    if (!player) return;
    const a = Math.atan2(player.y - this.y, player.x - this.x) + off;
    proj.push(new Proj(this.x, this.y, a, "licht", "#f80"));
  }

  rain() {
    if (!player) return;
    for (let i = 0; i < 6; i++) {
      proj.push(new Proj(player.x + (Math.random() * 400 - 200), -20, Math.PI / 2 + (Math.random() * 0.4 - 0.2), "licht", "#f80"));
    }
  }

  draw() {
    ctx.save(); ctx.translate(this.x, this.y);
    ctx.shadowBlur = 25; ctx.shadowColor = "#80f";
    
    if (this.stunned > 0 && Math.floor(this.stunned / 5) % 2 === 0) {
      ctx.globalAlpha = 0.5;
    }
    
    if (this.flash > 0) {
      ctx.globalAlpha = 0.7; ctx.fillStyle = "#fff"; ctx.fillRect(-50, -70, 100, 120); ctx.globalAlpha = 1;
    }
    if (IMG.licht_idle.complete && IMG.licht_idle.width > 0) {
      ctx.drawImage(IMG.licht_idle, -40, -60, 80, 100);
    } else {
      ctx.fillStyle = "#80f"; ctx.fillRect(-40, -60, 80, 100);
      ctx.fillStyle = "#fff"; ctx.fillRect(-30, -40, 15, 15); ctx.fillRect(15, -40, 15, 15);
    }
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.restore();
    const bw = 400, bx = this.x - 200;
    ctx.fillStyle = "#000"; ctx.fillRect(bx, this.y - 80, bw, 12);
    ctx.fillStyle = "#f00"; ctx.fillRect(bx + 2, this.y - 78, (bw - 4) * (this.hp / this.maxhp), 8);
    ctx.fillStyle = "#fff"; ctx.font = "14px Arial"; ctx.textAlign = "center";
    ctx.fillText("PHASE " + this.phase, this.x, this.y - 90); ctx.textAlign = "left";
  }
}

class Clone {
  constructor(x, y) {
    this.x = x + (Math.random() * 120 - 60); this.y = y + (Math.random() * 60 - 30);
    this.hp = 40; this.maxhp = 40; this.cool = Math.random() * 60;
    this.stunned = 0;
  }
  upd() {
    if (this.hp <= 0) return;
    if (this.stunned > 0) {
      this.stunned--;
      return;
    }
    this.cool--;
    if (this.cool <= 0 && Math.random() < 0.03) {
      if (player) {
        const a = Math.atan2(player.y - this.y, player.x - this.x);
        proj.push(new Proj(this.x, this.y, a, "licht", "#f80"));
      }
      this.cool = 90;
    }
  }
  draw() {
    if (this.hp <= 0) return;
    ctx.save(); ctx.translate(this.x, this.y);
    
    if (this.stunned > 0 && Math.floor(this.stunned / 5) % 2 === 0) {
      ctx.globalAlpha = 0.5;
    }
    
    ctx.shadowBlur = 10; ctx.shadowColor = "#f0f";
    if (IMG.licht_clone.complete && IMG.licht_clone.width > 0) {
      ctx.drawImage(IMG.licht_clone, -20, -20, 40, 40);
    } else {
      ctx.fillStyle = "#f0f"; ctx.fillRect(-20, -20, 40, 40);
    }
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.restore();
    ctx.fillStyle = "#000"; ctx.fillRect(this.x - 22, this.y - 28, 44, 6);
    ctx.fillStyle = "#f00"; ctx.fillRect(this.x - 20, this.y - 26, 40 * (this.hp / this.maxhp), 2);
  }
}

class BlackHole {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.life = 360;
    this.active = true;
    this.radius = 30;
  }

  upd() {
    this.life--;
    if (this.life <= 0) this.active = false;
    
    if (player && player.type === "yami") {
      this.x = player.x + 24;
      this.y = player.y - 40;
    }
    
    if (Math.random() < 0.3) {
      addPart(this.x, this.y, "#000", 2);
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    
    ctx.shadowBlur = 25;
    ctx.shadowColor = "#000";
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.globalAlpha = 0.5;
    ctx.strokeStyle = "#666";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, this.radius + 10, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.restore();
  }
}

class LightningPulse {
  constructor(x, y, angle) {
    this.x = x;
    this.y = y;
    this.vx = Math.cos(angle) * 15;
    this.vy = Math.sin(angle) * 15;
    this.life = 100;
    this.pullRadius = 320;
    this.angle = angle;
  }

  upd() {
    this.life--;
    this.x += this.vx;
    this.y += this.vy;
    
    const pulseRange = this.pullRadius;
    
    if (boss && Math.abs(this.x - boss.x) < 40 && Math.abs(this.y - boss.y) < 50) {
      boss.hp -= 20;
      boss.flash = 5;
      boss.stunned = 120;
      this.life = 0;
      combo++;
      comboTime = 120;
      shake = 8;
      addPart(this.x, this.y, "#0ff", 25);
      if (player) player.transformMeter = Math.min(600, player.transformMeter + 20);
    } else if (boss && Math.hypot(boss.x - this.x, boss.y - this.y) < pulseRange) {
      const pullAngle = Math.atan2(this.y - boss.y, this.x - boss.x);
      boss.x += Math.cos(pullAngle) * 3;
      boss.y += Math.sin(pullAngle) * 3;
    }
    
    clones.forEach(c => {
      if (c.hp > 0) {
        if (Math.abs(this.x - c.x) < 40 && Math.abs(this.y - c.y) < 40) {
          c.hp -= 20;
          c.stunned = 120;
          this.life = 0;
          combo++;
          comboTime = 120;
          addPart(this.x, this.y, "#0ff", 20);
          if (player) player.transformMeter = Math.min(600, player.transformMeter + 20);
        } else if (Math.hypot(c.x - this.x, c.y - this.y) < pulseRange) {
          const pullAngle = Math.atan2(this.y - c.y, this.x - c.x);
          c.x += Math.cos(pullAngle) * 3;
          c.y += Math.sin(pullAngle) * 3;
        }
      }
    });
    
    if (Math.random() < 0.3) {
      addPart(this.x, this.y, "#0ff", 3);
      addPart(this.x, this.y, "#000", 2);
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    
    ctx.shadowBlur = 20;
    ctx.shadowColor = "#0ff";
    
    ctx.fillStyle = "#0ff";
    ctx.beginPath();
    ctx.arc(0, 0, 25, 0, Math.PI * 2);
    ctx.fill();
    
    for (let i = 0; i < 4; i++) {
      const stripeAngle = (i * Math.PI / 2);
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(Math.cos(stripeAngle) * 10, Math.sin(stripeAngle) * 10);
      ctx.lineTo(Math.cos(stripeAngle) * 25, Math.sin(stripeAngle) * 25);
      ctx.stroke();
    }
    
    ctx.globalAlpha = 0.3;
    ctx.strokeStyle = "#0ff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, 40, 0, Math.PI * 2);
    ctx.stroke();
    
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.restore();
  }
}

class SeaDragon {
  constructor(x, y, transformed) {
    this.x = x;
    this.y = y;
    this.life = 300;
    this.w = 120;
    this.h = 60;
    this.transformed = transformed || false;
  }

  upd() {
    this.life--;
    
    const dx = mouse.x + cam - this.x;
    const dy = mouse.y - this.y;
    const angle = Math.atan2(dy, dx);
    this.x += Math.cos(angle) * 4;
    this.y += Math.sin(angle) * 4;
    
    const damage = this.transformed ? 122 : 120;
    if (boss && Math.abs(this.x - boss.x) < 70 && Math.abs(this.y - boss.y) < 50) {
      if (!this.hitBossThisFrame) {
        boss.hp -= damage;
        boss.flash = 5;
        combo++;
        comboTime = 120;
        shake = 8;
        addPart(boss.x, boss.y, "#4af", 25);
        this.hitBossThisFrame = true;
        this.life = Math.min(this.life, 60);
        if (player) player.transformMeter = Math.min(600, player.transformMeter + damage);
      }
    } else {
      this.hitBossThisFrame = false;
    }
    
    clones.forEach(c => {
      if (c.hp > 0 && Math.abs(this.x - c.x) < 70 && Math.abs(this.y - c.y) < 50) {
        if (!c.hitByDragon) {
          c.hp -= damage;
          combo++;
          comboTime = 120;
          addPart(c.x, c.y, "#4af", 20);
          c.hitByDragon = true;
          if (player) player.transformMeter = Math.min(600, player.transformMeter + damage);
          setTimeout(() => c.hitByDragon = false, 100);
        }
      }
    });
    
    if (Math.random() < 0.3) {
      addPart(this.x, this.y, "#4af", 5);
      addPart(this.x, this.y, "#fff", 3);
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    
    ctx.fillStyle = "#4af";
    ctx.globalAlpha = Math.min(1, this.life / 60);
    ctx.fillRect(-60, -30, 120, 60);
    
    ctx.fillStyle = "#fff";
    ctx.fillRect(50, -20, 15, 40);
    ctx.fillStyle = "#4af";
    ctx.fillRect(50, -25, 15, 5);
    ctx.fillRect(50, 20, 15, 5);
    
    ctx.fillStyle = "#fff";
    ctx.fillRect(20, -35, 25, 5);
    ctx.fillRect(20, -40, 5, 10);
    
    ctx.fillStyle = "#000";
    ctx.fillRect(25, -25, 8, 8);
    
    ctx.shadowBlur = 20;
    ctx.shadowColor = "#4af";
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = "#4af";
    ctx.fillRect(-60, -30, 120, 60);
    
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
    ctx.restore();
  }
}

class HomingProjectile {
  constructor(x, y, angle, transformed) {
    this.x = x;
    this.y = y;
    this.vx = Math.cos(angle) * 8;
    this.vy = Math.sin(angle) * 8;
    this.life = 300;
    this.homingTime = 300;
    this.speed = 8;
    this.target = null;
    this.transformed = transformed || false;
  }

  upd() {
    this.life--;
    this.homingTime--;
    
    if (this.homingTime > 0) {
      let closest = null;
      let closestDist = 999999;
      
      if (boss && boss.hp > 0) {
        const dist = Math.hypot(boss.x - this.x, boss.y - this.y);
        if (dist < closestDist) {
          closest = boss;
          closestDist = dist;
        }
      }
      
      clones.forEach(c => {
        if (c.hp > 0) {
          const dist = Math.hypot(c.x - this.x, c.y - this.y);
          if (dist < closestDist) {
            closest = c;
            closestDist = dist;
          }
        }
      });
      
      if (closest) {
        const angle = Math.atan2(closest.y - this.y, closest.x - this.x);
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
      }
    }
    
    this.x += this.vx;
    this.y += this.vy;
    
    const damage = this.transformed ? 31 : 30;
    
    if (boss && Math.abs(this.x - boss.x) < 40 && Math.abs(this.y - boss.y) < 50) {
      boss.hp -= damage;
      boss.flash = 5;
      this.life = 0;
      combo++;
      comboTime = 120;
      shake = 5;
      addPart(this.x, this.y, "#ff0", 20);
      if (player) player.transformMeter = Math.min(600, player.transformMeter + damage);
    }
    
    clones.forEach(c => {
      if (c.hp > 0 && Math.abs(this.x - c.x) < 25 && Math.abs(this.y - c.y) < 25) {
        c.hp -= damage;
        this.life = 0;
        combo++;
        comboTime = 120;
        addPart(this.x, this.y, "#f0f", 15);
        if (player) player.transformMeter = Math.min(600, player.transformMeter + damage);
      }
    });
    
    if (Math.random() < 0.4) {
      addPart(this.x, this.y, "#000", 2);
      addPart(this.x, this.y, "#f00", 1);
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(Math.atan2(this.vy, this.vx));
    
    ctx.shadowBlur = 20;
    ctx.shadowColor = "#f00";
    ctx.fillStyle = "#000";
    ctx.fillRect(-25, -6, 50, 12);
    ctx.strokeStyle = "#f00";
    ctx.lineWidth = 2;
    ctx.strokeRect(-25, -6, 50, 12);
    
    ctx.shadowBlur = 0;
    ctx.restore();
  }
}

function drawBG() {
  const g = ctx.createLinearGradient(0, 0, 0, 720);
  g.addColorStop(0, "#1a1a3e"); g.addColorStop(1, "#0a0a1a");
  ctx.fillStyle = g; ctx.fillRect(0, 0, 1280, 720);
  if (IMG.bg.complete && IMG.bg.width > 0) {
    ctx.globalAlpha = 0.3; ctx.drawImage(IMG.bg, -cam * 0.1, 0, 1600, 720); ctx.globalAlpha = 1;
  }
}

function loop() {
  if (loaded < total) {
    ctx.fillStyle = "#1a1a3e"; ctx.fillRect(0, 0, 1280, 720);
    ctx.fillStyle = "#fff"; ctx.font = "32px Arial"; ctx.textAlign = "center";
    ctx.fillText("Loading... " + loaded + "/" + total, 640, 360); ctx.textAlign = "left";
    requestAnimationFrame(loop); return;
  }
  
  // Check for cheat menu activation (Shift + L + 8)
  if (keys.shift && keys.l && keys["8"]) {
    cheatMenuOpen = !cheatMenuOpen;
    keys.shift = false;
    keys.l = false;
    keys["8"] = false;
  }

  if (hitStop > 0) { hitStop--; requestAnimationFrame(loop); return; }

  ctx.setTransform(1, 0, 0, 1, 0, 0);
  if (shake > 0) { ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake); shake--; }
  
  // Screen invert effect
  if (invertScreen > 0) {
    invertScreen--;
    ctx.filter = "invert(1)";
  } else {
    ctx.filter = "none";
  }
  
  ctx.clearRect(0, 0, 1280, 720);

  if (state === "title") {
    drawBG();
    ctx.fillStyle = "#fd7"; ctx.font = "bold 72px Arial"; ctx.textAlign = "center";
    ctx.shadowBlur = 20; ctx.shadowColor = "#fd7"; ctx.fillText("BLACK CLOVER", 640, 280); ctx.shadowBlur = 0;
    ctx.fillStyle = "#fff"; ctx.font = "28px Arial"; ctx.fillText("Boss Fight: Licht", 640, 340);
    ctx.font = "20px Arial"; ctx.fillStyle = "#888"; ctx.fillText("Press ENTER to continue", 640, 400);
    if (keys.enter && !enterPrev) { state = "menu"; menuState = "main"; selected = 0; }
    ctx.textAlign = "left";
  }

  else if (state === "menu") {
    drawBG();
    
    if (menuState === "main") {
      ctx.fillStyle = "#fd7"; ctx.font = "bold 56px Arial"; ctx.textAlign = "center";
      ctx.shadowBlur = 15; ctx.shadowColor = "#fd7"; ctx.fillText("MAIN MENU", 640, 180); ctx.shadowBlur = 0;
      
      const menuOptions = ["PLAY", "ACHIEVEMENTS", "STATS", "CREDITS"];
      menuOptions.forEach((opt, i) => {
        const y = 280 + i * 80;
        const sel = i === selected;
        ctx.fillStyle = sel ? "rgba(255,215,0,0.2)" : "rgba(255,255,255,0.05)";
        ctx.fillRect(390, y - 40, 500, 70);
        ctx.strokeStyle = sel ? "#fd7" : "#666"; ctx.lineWidth = 3; ctx.strokeRect(390, y - 40, 500, 70);
        ctx.fillStyle = sel ? "#fd7" : "#aaa"; ctx.font = "bold 36px Arial";
        ctx.fillText(opt, 640, y + 5);
      });
      
      ctx.font = "18px Arial"; ctx.fillStyle = "#888"; ctx.fillText("W/S: Select | ENTER: Confirm", 640, 660);
      
      if (keys.w && !keys.wp) { selected = (selected + 3) % 4; keys.wp = true; }
      if (!keys.w) keys.wp = false;
      if (keys.s && !keys.sp) { selected = (selected + 1) % 4; keys.sp = true; }
      if (!keys.s) keys.sp = false;
      
      if (keys.enter && !enterPrev) {
        if (selected === 0) { state = "select"; selected = 0; }
        else if (selected === 1) { menuState = "achievements"; }
        else if (selected === 2) { menuState = "stats"; }
        else if (selected === 3) { menuState = "credits"; }
      }
      ctx.textAlign = "left";
    }
    
    else if (menuState === "achievements") {
      ctx.fillStyle = "#fff"; ctx.font = "bold 48px Arial"; ctx.textAlign = "center";
      ctx.fillText("ACHIEVEMENTS", 640, 120);
      
      const unlockedCount = Object.values(achievements).filter(a => a).length;
      const totalCount = achievementList.length;
      ctx.font = "32px Arial"; ctx.fillStyle = "#fd7";
      ctx.textAlign = "right";
      ctx.fillText(unlockedCount + "/" + totalCount, 1200, 120);
      
      ctx.textAlign = "left";
      ctx.font = "24px Arial";
      let y = 200;
      achievementList.forEach((ach, i) => {
        const unlocked = achievements[ach.id];
        ctx.fillStyle = unlocked ? "rgba(255,215,0,0.2)" : "rgba(100,100,100,0.1)";
        ctx.fillRect(100, y - 30, 1080, 50);
        
        ctx.strokeStyle = unlocked ? "#fd7" : "#444";
        ctx.lineWidth = 2;
        ctx.strokeRect(100, y - 30, 1080, 50);
        
        ctx.fillStyle = unlocked ? "#fd7" : "#666";
        ctx.font = "bold 22px Arial";
        ctx.fillText(ach.name, 120, y);
        
        ctx.fillStyle = unlocked ? "#fff" : "#555";
        ctx.font = "18px Arial";
        ctx.fillText(ach.desc, 500, y);
        
        if (unlocked) {
          ctx.fillStyle = "#0f0";
          ctx.font = "20px Arial";
          ctx.fillText("✓", 1140, y);
        }
        
        y += 55;
      });
      
      ctx.textAlign = "center";
      ctx.font = "20px Arial"; ctx.fillStyle = "#888";
      ctx.fillText("Press ESC to return", 640, 680);
      if (keys.escape || keys.backspace) { menuState = "main"; selected = 1; }
      ctx.textAlign = "left";
    }
    
    else if (menuState === "stats") {
      ctx.fillStyle = "#fff"; ctx.font = "bold 48px Arial"; ctx.textAlign = "center";
      ctx.fillText("STATISTICS", 640, 120);
      
      ctx.font = "32px Arial"; ctx.fillStyle = "#aaa";
      ctx.fillText("Wins: " + stats.wins, 640, 240);
      ctx.fillText("Losses: " + stats.losses, 640, 300);
      
      const totalPlays = stats.astaPlays + stats.noellePlays + stats.luckPlays + stats.yamiPlays;
      let mostUsed = "None";
      if (totalPlays > 0) {
        const maxPlays = Math.max(stats.astaPlays, stats.noellePlays, stats.luckPlays, stats.yamiPlays);
        if (stats.astaPlays === maxPlays) mostUsed = "Asta";
        else if (stats.noellePlays === maxPlays) mostUsed = "Noelle";
        else if (stats.luckPlays === maxPlays) mostUsed = "Luck";
        else mostUsed = "Yami";
      }
      ctx.fillText("Most Used: " + mostUsed, 640, 360);
      
      ctx.font = "24px Arial"; ctx.fillStyle = "#888";
      ctx.fillText("Press ESC to return", 640, 650);
      if (keys.escape || keys.backspace) { menuState = "main"; selected = 2; }
      ctx.textAlign = "left";
    }
    
    else if (menuState === "credits") {
      ctx.fillStyle = "#fff"; ctx.font = "bold 48px Arial"; ctx.textAlign = "center";
      ctx.fillText("CREDITS", 640, 120);
      
      ctx.font = "36px Arial"; ctx.fillStyle = "#fd7";
      ctx.fillText("Created By", 640, 300);
      ctx.font = "42px Arial"; ctx.fillStyle = "#fff";
      ctx.fillText("Lehith Suryadevara", 640, 370);
      
      ctx.font = "20px Arial"; ctx.fillStyle = "#888";
      ctx.fillText("Press ESC to return", 640, 650);
      if (keys.escape || keys.backspace) { 
        menuState = "main"; 
        selected = 3;
        unlockAchievement("viewCredits");
      }
      ctx.textAlign = "left";
    }
  }

  else if (state === "select") {
    drawBG();
    ctx.fillStyle = "#fff"; ctx.font = "bold 42px Arial"; ctx.textAlign = "center";
    ctx.fillText("SELECT YOUR FIGHTER", 640, 140);
    chars.forEach((c, i) => {
      const y = 240 + i * 90, sel = i === selected;
      const locked = c.locked && !achievements.win25;
      ctx.fillStyle = sel ? "rgba(255,215,0,0.2)" : "rgba(255,255,255,0.05)";
      ctx.fillRect(390, y - 40, 500, 70);
      ctx.strokeStyle = locked ? "#444" : (sel ? "#fd7" : "#666");
      ctx.lineWidth = 3; ctx.strokeRect(390, y - 40, 500, 70);
      ctx.fillStyle = locked ? "#666" : (sel ? c.col : "#aaa");
      ctx.font = "bold 32px Arial";
      ctx.fillText(c.name, 490, y + 5);
      ctx.font = "18px Arial";
      ctx.fillStyle = locked ? "#444" : "#888";
      ctx.fillText(locked ? "LOCKED - GET 25 WINS" : c.info, 490, y + 30);
    });
    ctx.font = "18px Arial"; ctx.fillStyle = "#888"; ctx.fillText("W/S: Select | ENTER: Confirm", 640, 640);
    if (keys.w && !keys.wp) { selected = (selected + chars.length - 1) % chars.length; keys.wp = true; }
    if (!keys.w) keys.wp = false;
    if (keys.s && !keys.sp) { selected = (selected + 1) % chars.length; keys.sp = true; }
    if (!keys.s) keys.sp = false;
    if (keys.enter && !enterPrev) {
      const ch = chars[selected];
      if (!(ch.locked && !achievements.win25)) {
        player = new Player(ch); boss = new Boss();
        wasHit = false;
        if (ch.id === "asta") stats.astaPlays++;
        else if (ch.id === "noelle") stats.noellePlays++;
        else if (ch.id === "luck") stats.luckPlays++;
        else if (ch.id === "yami") stats.yamiPlays++;
        proj.length = 0; clones.length = 0; part.length = 0; dragons.length = 0; homingProj.length = 0; lightningPulses.length = 0; blackHoles.length = 0; phase = 1; combo = 0; state = "play";
      }
    }
    ctx.textAlign = "left";
  }

  else if (state === "play") {
    cam = Math.max(0, player.x - 640);
    drawBG();
    ctx.save(); ctx.translate(-cam, 0);
    plat.forEach(p => {
      ctx.fillStyle = p.c; ctx.fillRect(p.x, p.y, p.w, p.h);
      ctx.fillStyle = "rgba(255,255,255,0.1)"; ctx.fillRect(p.x, p.y, p.w, 3);
    });
    player.upd(); boss.upd();
    clones.forEach(c => c.upd());
    for (let i = dragons.length - 1; i >= 0; i--) {
      dragons[i].upd();
      if (dragons[i].life <= 0) dragons.splice(i, 1);
    }
    for (let i = homingProj.length - 1; i >= 0; i--) {
      homingProj[i].upd();
      if (homingProj[i].life <= 0) homingProj.splice(i, 1);
    }
    for (let i = lightningPulses.length - 1; i >= 0; i--) {
      lightningPulses[i].upd();
      if (lightningPulses[i].life <= 0) lightningPulses.splice(i, 1);
    }
    for (let i = blackHoles.length - 1; i >= 0; i--) {
      blackHoles[i].upd();
      if (!blackHoles[i].active) blackHoles.splice(i, 1);
    }
    for (let i = proj.length - 1; i >= 0; i--) { proj[i].upd(); if (proj[i].t <= 0) proj.splice(i, 1); }
    updPart(); drawPart();
    updateAchievementPopups();
    clones.forEach(c => c.draw()); 
    dragons.forEach(d => d.draw());
    homingProj.forEach(h => h.draw());
    lightningPulses.forEach(lp => lp.draw());
    blackHoles.forEach(bh => bh.draw());
    boss.draw(); player.draw();
    proj.forEach(p => p.draw());
    ctx.restore();

    const hw = 300;
    ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(20, 20, hw + 10, 35);
    ctx.fillStyle = "#f00"; ctx.fillRect(25, 25, hw * (player.hp / player.maxhp), 25);
    ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(25, 25, hw, 25);
    ctx.fillStyle = "#fff"; ctx.font = "16px Arial"; ctx.fillText("HP: " + Math.floor(player.hp) + "/" + player.maxhp, 30, 43);

    const bw = 600, bx = 340;
    ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(bx - 5, 20, bw + 10, 40);
    ctx.fillStyle = "#80f"; ctx.fillRect(bx, 25, bw * (boss.hp / boss.maxhp), 30);
    ctx.strokeStyle = "#fff"; ctx.lineWidth = 3; ctx.strokeRect(bx, 25, bw, 30);
    ctx.fillStyle = "#fff"; ctx.font = "bold 18px Arial"; ctx.textAlign = "center";
    ctx.fillText("LICHT - Phase " + boss.phase, 640, 45); ctx.textAlign = "left";

    if (combo > 1) {
      ctx.fillStyle = "#ff0"; ctx.font = "bold 32px Arial"; ctx.textAlign = "right";
      ctx.fillText(combo + " HIT COMBO!", 1250, 100); ctx.textAlign = "left";
    }
    ctx.fillStyle = "rgba(255,255,255,0.6)"; ctx.font = "14px Arial";
    const abilityText = player.type === "asta" ? "Q: Demon Slash | E: Black Meteorite | R: Black Form" : 
                        player.type === "noelle" ? "Q: Sea Dragon | E: Shield | R: Valkyrie Dress" :
                        player.type === "yami" ? "Q: Dimensional Slash | E: Black Hole" :
                        "T: Lightning Pulse | E: Lightning Dash | R: True Lightning";
    ctx.fillText("A/D: Move | SPACE: Jump | SHIFT: Dash | CLICK: Attack | " + abilityText, 20, 700);
    
    if (player.dashCooldown > 0) {
      const cooldownPercent = player.dashCooldown / 300;
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(20, 600, 120, 30);
      ctx.fillStyle = "#666";
      ctx.fillRect(25, 605, 110, 20);
      ctx.fillStyle = "#0ff";
      ctx.fillRect(25, 605, 110 * (1 - cooldownPercent), 20);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.strokeRect(25, 605, 110, 20);
      ctx.fillStyle = "#fff";
      ctx.font = "12px Arial";
      ctx.fillText("DASH: " + Math.ceil(player.dashCooldown / 60) + "s", 30, 618);
    }
    
    if (player.specialCooldown > 0) {
      let maxCool = 300;
      if (player.type === "noelle") maxCool = 600;
      if (player.type === "luck") maxCool = 240;
      if (player.type === "yami") maxCool = 480;
      const cooldownPercent = player.specialCooldown / maxCool;
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(150, 600, 150, 30);
      ctx.fillStyle = "#666";
      ctx.fillRect(155, 605, 140, 20);
      const coolCol = player.type === "asta" ? "#f00" : (player.type === "luck" ? "#0ff" : (player.type === "yami" ? "#000" : "#4af"));
      ctx.fillStyle = coolCol;
      ctx.fillRect(155, 605, 140 * (1 - cooldownPercent), 20);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.strokeRect(155, 605, 140, 20);
      ctx.fillStyle = "#fff";
      ctx.font = "12px Arial";
      const abilityName = player.type === "asta" ? "DEMON SLASH" : (player.type === "luck" ? "LIGHTNING PULSE" : (player.type === "yami" ? "DIMENSION SLASH" : "SEA DRAGON"));
      ctx.fillText(abilityName + ": " + Math.ceil(player.specialCooldown / 60) + "s", 160, 618);
    }
    
    if (player.shieldActive > 0 && player.type === "asta") {
    } else if (player.shieldCooldown > 0 || player.blackHoleActive > 0) {
      let maxCool = 420;
      if (player.type === "noelle") maxCool = 480;
      if (player.type === "luck") maxCool = 300;
      if (player.type === "yami") maxCool = 360;
      
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(310, 600, 170, 30);
      ctx.fillStyle = "#666";
      ctx.fillRect(315, 605, 160, 20);
      
      const coolCol = player.type === "asta" ? "#f00" : (player.type === "luck" ? "#0ff" : (player.type === "yami" ? "#000" : "#4af"));
      ctx.fillStyle = coolCol;
      
      if (player.blackHoleActive > 0) {
        const activePercent = player.blackHoleActive / 360;
        ctx.fillRect(315, 605, 160 * activePercent, 20);
      } else {
        const cooldownPercent = player.shieldCooldown / maxCool;
        ctx.fillRect(315, 605, 160 * (1 - cooldownPercent), 20);
      }
      
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.strokeRect(315, 605, 160, 20);
      ctx.fillStyle = "#fff";
      ctx.font = "12px Arial";
      
      const abilityName = player.type === "asta" ? "METEORITE" : (player.type === "luck" ? "LIGHTNING DASH" : (player.type === "yami" ? "BLACK HOLE" : "SHIELD"));
      
      if (player.blackHoleActive > 0) {
        ctx.fillText(abilityName + ": " + Math.ceil(player.blackHoleActive / 60) + "s", 320, 618);
      } else if (player.shieldCooldown > 0) {
        ctx.fillText(abilityName + ": " + Math.ceil(player.shieldCooldown / 60) + "s", 320, 618);
      }
    } else if (player.type === "noelle" && player.shieldActive > 0) {
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(310, 600, 170, 30);
      ctx.fillStyle = "#4af";
      ctx.fillRect(315, 605, 160, 20);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.strokeRect(315, 605, 160, 20);
      ctx.fillStyle = "#fff";
      ctx.font = "12px Arial";
      ctx.fillText("SHIELD: ACTIVE", 320, 618);
    }
    
    if (player.cool > 0) {
      let maxCool = 120;
      if (player.type === "noelle") maxCool = 90;
      if (player.type === "luck") maxCool = 72;
      if (player.type === "yami") maxCool = 150;
      const coolPercent = player.cool / maxCool;
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(490, 600, 140, 30);
      ctx.fillStyle = "#666";
      ctx.fillRect(495, 605, 130, 20);
      ctx.fillStyle = player.col;
      ctx.fillRect(495, 605, 130 * (1 - coolPercent), 20);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.strokeRect(495, 605, 130, 20);
      ctx.fillStyle = "#fff";
      ctx.font = "12px Arial";
      ctx.fillText("ATTACK: " + (player.cool / 60).toFixed(1) + "s", 500, 618);
    }
    
    const transformColor = player.type === "asta" ? "#f00" : (player.type === "luck" ? "#0ff" : "#4af");
    if (player.type !== "yami") {
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillRect(950, 600, 300, 40);
      ctx.fillStyle = "#666";
      ctx.fillRect(960, 610, 280, 20);
      ctx.fillStyle = transformColor;
      ctx.fillRect(960, 610, 280 * (player.transformMeter / 600), 20);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.strokeRect(960, 610, 280, 20);
      ctx.fillStyle = "#fff";
      ctx.font = "14px Arial";
      ctx.textAlign = "center";
      const transformText = player.transformed ? "TRANSFORMED!" : (player.transformUsed ? "ALREADY USED" : (player.transformMeter >= 600 ? "R: TRANSFORM" : "TRANSFORM"));
      ctx.fillText(transformText, 1100, 625);
      ctx.textAlign = "left";
      
      if (player.transformed) {
        ctx.fillStyle = transformColor;
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Time: " + Math.ceil(player.transformTime / 60) + "s", 1100, 607);
        ctx.textAlign = "left";
      }
    }
    
    // Draw achievement popups
    drawAchievementPopups();
  }

  else {
    drawBG();
    ctx.fillStyle = state === "win" ? "#0f0" : "#f00";
    ctx.font = "bold 80px Arial"; ctx.textAlign = "center";
    ctx.shadowBlur = 30; ctx.shadowColor = ctx.fillStyle;
    ctx.fillText(state === "win" ? "VICTORY!" : "DEFEAT", 640, 280); ctx.shadowBlur = 0;
    ctx.font = "32px Arial"; ctx.fillStyle = "#fff"; ctx.fillText("Phase Reached: " + phase, 640, 350);
    if (combo > 5) { ctx.fillStyle = "#ff0"; ctx.fillText("Max Combo: " + combo, 640, 400); }
    ctx.font = "24px Arial"; ctx.fillStyle = "#888";
    ctx.fillText("Press ENTER to return to menu", 640, 500);
    if (keys.enter && !enterPrev) { state = "menu"; menuState = "main"; selected = 0; }
    ctx.textAlign = "left";
  }
  
  // Draw cheat menu
  if (cheatMenuOpen) {
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    
    // Background overlay
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.fillRect(0, 0, 1280, 720);
    
    // Cheat menu box
    ctx.fillStyle = "rgba(20,20,20,0.95)";
    ctx.fillRect(390, 200, 500, 320);
    ctx.strokeStyle = "#f00";
    ctx.lineWidth = 3;
    ctx.strokeRect(390, 200, 500, 320);
    
    // Title
    ctx.fillStyle = "#f00";
    ctx.font = "bold 36px Arial";
    ctx.textAlign = "center";
    ctx.fillText("CHEAT MENU", 640, 250);
    
    // Options
    ctx.font = "24px Arial";
    ctx.fillStyle = "#fff";
    ctx.fillText("Press U: Unlock All Achievements", 640, 320);
    
    ctx.fillStyle = "#888";
    ctx.font = "18px Arial";
    ctx.fillText("(Shift + L + 8 to close)", 640, 480);
    
    ctx.textAlign = "left";
    ctx.restore();
    
    // Unlock all achievements
    if (keys.u) {
      Object.keys(achievements).forEach(key => {
        achievements[key] = true;
      });
      stats.wins = 50; // Ensure all win achievements work
      keys.u = false;
    }
  }

  enterPrev = keys.enter;
  mouse.prev = mouse.down;
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
