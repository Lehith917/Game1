<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Black Clover Boss Battle</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      font-family: Arial, sans-serif;
    }
    canvas {
      border: 3px solid #FFD700;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
      max-width: 100%;
      height: auto;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    canvas.width = 800;
    canvas.height = 600;

    let gameState = 'menu';
    let selectedCharacter = null;
    let keys = {};
    
    // Player
    let player = {
      x: 100,
      y: 500,
      width: 50,
      height: 50,
      velocityY: 0,
      speed: 5,
      jumpPower: 15,
      isJumping: false,
      health: 100,
      maxHealth: 100,
      canDoubleJump: false,
      hasDoubleJumped: false
    };

    // Transformation system
    let transformMeter = 0;
    let isTransformed = false;
    let transformTimeLeft = 0;
    let hasUsedTransform = false;

    // Noelle specific
    let shieldActive = false;
    let shieldCooldown = 0;
    let seaDragonCooldown = 0;

    // Licht Boss
    let licht = {
      x: 650,
      y: 450,
      width: 60,
      height: 80,
      health: 500,
      maxHealth: 500,
      phase: 1,
      attackCooldown: 0,
      movementTimer: 0,
      direction: 1
    };

    let clones = [];
    let projectiles = [];
    let playerAttacks = [];
    let particles = [];

    // Input handling
    window.addEventListener('keydown', (e) => {
      keys[e.key.toLowerCase()] = true;
      
      if (gameState === 'menu') {
        if (e.key === '1') {
          selectedCharacter = 'asta';
          startGame();
        } else if (e.key === '2') {
          selectedCharacter = 'noelle';
          startGame();
        }
      }
      
      // Transformation activation
      if (e.key.toLowerCase() === 't' && transformMeter >= 600 && !isTransformed && !hasUsedTransform) {
        activateTransformation();
      }
    });

    window.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    function startGame() {
      gameState = 'playing';
      player.health = 100;
      player.x = 100;
      player.y = 500;
      licht.health = 500;
      licht.phase = 1;
      projectiles = [];
      playerAttacks = [];
      clones = [];
      particles = [];
      transformMeter = 0;
      isTransformed = false;
      transformTimeLeft = 0;
      hasUsedTransform = false;
      shieldActive = false;
      shieldCooldown = 0;
      seaDragonCooldown = 0;
    }

    function activateTransformation() {
      isTransformed = true;
      transformTimeLeft = 30;
      hasUsedTransform = true;
      
      if (selectedCharacter === 'asta') {
        // Black Asta transformation - pulse effect
        createPulseEffect();
        clearEnemyAttacks();
      }
    }

    function createPulseEffect() {
      // Create expanding pulse particles
      for (let i = 0; i < 50; i++) {
        const angle = (Math.PI * 2 * i) / 50;
        particles.push({
          x: player.x + player.width / 2,
          y: player.y + player.height / 2,
          vx: Math.cos(angle) * 8,
          vy: Math.sin(angle) * 8,
          life: 30,
          color: Math.random() > 0.5 ? '#FF0000' : '#000000',
          size: 6
        });
      }
    }

    function clearEnemyAttacks() {
      // Remove all enemy projectiles
      projectiles = [];
      
      // Destroy all clones
      clones.forEach(clone => {
        createDeathParticles(clone.x + clone.width / 2, clone.y + clone.height / 2, '#FFD700');
      });
      clones = [];
    }

    function updatePlayer() {
      // Apply gravity
      player.velocityY += 0.8;
      player.y += player.velocityY;

      // Ground collision
      if (player.y >= 500) {
        player.y = 500;
        player.velocityY = 0;
        player.isJumping = false;
        player.hasDoubleJumped = false;
      }

      // Movement with transformation buff
      let moveSpeed = player.speed;
      if (selectedCharacter === 'noelle' && isTransformed) {
        moveSpeed *= 1.03; // 3% movement buff
      }

      if (keys['a'] && player.x > 0) player.x -= moveSpeed;
      if (keys['d'] && player.x < canvas.width - player.width) player.x += moveSpeed;

      // Jump
      if (keys['w'] && !player.isJumping) {
        player.velocityY = -player.jumpPower;
        player.isJumping = true;
      }

      // Double jump for transformed Noelle
      if (selectedCharacter === 'noelle' && isTransformed) {
        if (keys['w'] && player.isJumping && !player.hasDoubleJumped && player.velocityY > 0) {
          player.velocityY = -player.jumpPower * 0.8;
          player.hasDoubleJumped = true;
        }
      }

      // Asta attacks
      if (selectedCharacter === 'asta') {
        if (keys[' '] && playerAttacks.length === 0) {
          let damage = 15;
          if (isTransformed) damage *= 1.05; // 5% damage buff
          
          playerAttacks.push({
            x: player.x + player.width,
            y: player.y + player.height / 2 - 10,
            width: 40,
            height: 20,
            damage: damage,
            speed: 10,
            color: isTransformed ? '#000000' : '#808080'
          });
        }
      }

      // Noelle attacks
      if (selectedCharacter === 'noelle') {
        // Shield (E key) - can't use Q while shield is active
        if (keys['e'] && shieldCooldown === 0) {
          shieldActive = true;
          shieldCooldown = 180;
        }

        if (shieldActive) {
          shieldCooldown--;
          if (shieldCooldown === 0) {
            shieldActive = false;
          }
        } else if (shieldCooldown > 0) {
          shieldCooldown--;
        }

        // Sea Dragon's Roar (Q key) - can't use while shield is active
        if (keys['q'] && seaDragonCooldown === 0 && !shieldActive) {
          let damage = 25;
          if (isTransformed) damage *= 1.02; // 2% damage buff
          
          playerAttacks.push({
            x: player.x + player.width,
            y: player.y,
            width: 60,
            height: 50,
            damage: damage,
            speed: 8,
            color: '#4169E1',
            type: 'dragon'
          });
          seaDragonCooldown = 120;
        }

        if (seaDragonCooldown > 0) seaDragonCooldown--;

        // Water ball (Space)
        if (keys[' '] && playerAttacks.filter(a => a.type !== 'dragon').length < 3) {
          let damage = 10;
          if (isTransformed) damage *= 1.02; // 2% damage buff
          
          playerAttacks.push({
            x: player.x + player.width,
            y: player.y + player.height / 2 - 8,
            width: 16,
            height: 16,
            damage: damage,
            speed: 12,
            color: '#87CEEB'
          });
        }
      }

      // Update transformation timer
      if (isTransformed) {
        transformTimeLeft -= 1/60;
        if (transformTimeLeft <= 0) {
          isTransformed = false;
          transformTimeLeft = 0;
        }
      }
    }

    function updateLicht() {
      licht.attackCooldown--;
      licht.movementTimer++;

      // Phase transitions
      if (licht.health < 333 && licht.phase === 1) {
        licht.phase = 2;
        spawnClones(2);
      }
      if (licht.health < 166 && licht.phase === 2) {
        licht.phase = 3;
        spawnClones(2);
      }

      // Movement pattern
      if (licht.movementTimer % 120 < 60) {
        licht.x += licht.direction * 2;
        if (licht.x > 700 || licht.x < 500) licht.direction *= -1;
      }

      // Attack patterns
      if (licht.attackCooldown <= 0) {
        if (licht.phase === 1) {
          shootProjectile(licht, 0);
          licht.attackCooldown = 60;
        } else if (licht.phase === 2) {
          shootProjectile(licht, 15);
          shootProjectile(licht, -15);
          licht.attackCooldown = 50;
        } else if (licht.phase === 3) {
          for (let angle = -30; angle <= 30; angle += 15) {
            shootProjectile(licht, angle);
          }
          licht.attackCooldown = 70;
        }
      }
    }

    function spawnClones(count) {
      for (let i = 0; i < count; i++) {
        clones.push({
          x: 400 + Math.random() * 200,
          y: 400 + Math.random() * 100,
          width: 50,
          height: 70,
          health: 30,
          attackCooldown: Math.random() * 60
        });
      }
    }

    function updateClones() {
      clones.forEach((clone, index) => {
        clone.attackCooldown--;
        
        if (clone.attackCooldown <= 0) {
          shootProjectile(clone, 0);
          clone.attackCooldown = 80;
        }

        if (clone.health <= 0) {
          clones.splice(index, 1);
          createDeathParticles(clone.x + clone.width / 2, clone.y + clone.height / 2, '#FFD700');
        }
      });
    }

    function shootProjectile(source, angleOffset) {
      const angle = Math.atan2(player.y - source.y, player.x - source.x) + (angleOffset * Math.PI / 180);
      projectiles.push({
        x: source.x + source.width / 2,
        y: source.y + source.height / 2,
        width: 16,
        height: 16,
        vx: Math.cos(angle) * 6,
        vy: Math.sin(angle) * 6,
        damage: 10
      });
    }

    function updateProjectiles() {
      projectiles.forEach((proj, index) => {
        proj.x += proj.vx;
        proj.y += proj.vy;

        // Bigger hitbox for better collision detection
        const projHitbox = {
          x: proj.x - 4,
          y: proj.y - 4,
          width: proj.width + 8,
          height: proj.height + 8
        };

        const playerHitbox = {
          x: player.x + 5,
          y: player.y + 5,
          width: player.width - 10,
          height: player.height - 10
        };

        if (checkCollision(projHitbox, playerHitbox)) {
          if (!shieldActive) {
            player.health -= proj.damage;
            createHitParticles(player.x + player.width / 2, player.y + player.height / 2);
          }
          projectiles.splice(index, 1);
        }

        if (proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height) {
          projectiles.splice(index, 1);
        }
      });
    }

    function updatePlayerAttacks() {
      playerAttacks.forEach((attack, index) => {
        attack.x += attack.speed;

        // Check collision with Licht (bigger hitbox)
        const lichtHitbox = {
          x: licht.x - 5,
          y: licht.y - 5,
          width: licht.width + 10,
          height: licht.height + 10
        };

        if (checkCollision(attack, lichtHitbox)) {
          licht.health -= attack.damage;
          transformMeter += attack.damage; // Add damage dealt to transform meter
          if (transformMeter > 600) transformMeter = 600;
          createHitParticles(licht.x + licht.width / 2, licht.y + licht.height / 2);
          playerAttacks.splice(index, 1);
          return;
        }

        // Check collision with clones (bigger hitbox)
        clones.forEach((clone) => {
          const cloneHitbox = {
            x: clone.x - 5,
            y: clone.y - 5,
            width: clone.width + 10,
            height: clone.height + 10
          };

          if (checkCollision(attack, cloneHitbox)) {
            clone.health -= attack.damage;
            transformMeter += attack.damage;
            if (transformMeter > 600) transformMeter = 600;
            createHitParticles(clone.x + clone.width / 2, clone.y + clone.height / 2);
            playerAttacks.splice(index, 1);
          }
        });

        if (attack.x > canvas.width) {
          playerAttacks.splice(index, 1);
        }
      });
    }

    function checkCollision(rect1, rect2) {
      return rect1.x < rect2.x + rect2.width &&
             rect1.x + rect1.width > rect2.x &&
             rect1.y < rect2.y + rect2.height &&
             rect1.y + rect1.height > rect2.y;
    }

    function createHitParticles(x, y) {
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 6,
          vy: (Math.random() - 0.5) * 6,
          life: 30,
          color: '#FFD700',
          size: 4
        });
      }
    }

    function createDeathParticles(x, y, color) {
      for (let i = 0; i < 20; i++) {
        particles.push({
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          life: 50,
          color: color,
          size: 6
        });
      }
    }

    function updateParticles() {
      particles.forEach((p, index) => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) {
          particles.splice(index, 1);
        }
      });
    }

    function draw() {
      ctx.fillStyle = '#0a0a1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw ground
      ctx.fillStyle = '#1a3a1a';
      ctx.fillRect(0, 550, canvas.width, 50);

      if (gameState === 'menu') {
        drawMenu();
      } else if (gameState === 'playing') {
        drawGame();
      } else if (gameState === 'victory') {
        drawVictory();
      } else if (gameState === 'defeat') {
        drawDefeat();
      }
    }

    function drawMenu() {
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('BLACK CLOVER', canvas.width / 2, 150);
      
      ctx.font = '32px Arial';
      ctx.fillText('Boss Battle', canvas.width / 2, 200);
      
      ctx.font = '24px Arial';
      ctx.fillStyle = '#FFF';
      ctx.fillText('Select Your Character', canvas.width / 2, 280);
      
      ctx.fillStyle = '#4169E1';
      ctx.fillRect(200, 320, 150, 60);
      ctx.fillStyle = '#32CD32';
      ctx.fillRect(450, 320, 150, 60);
      
      ctx.fillStyle = '#FFF';
      ctx.font = '20px Arial';
      ctx.fillText('Press 1', 275, 345);
      ctx.fillText('ASTA', 275, 370);
      
      ctx.fillText('Press 2', 525, 345);
      ctx.fillText('NOELLE', 525, 370);
      
      ctx.font = '16px Arial';
      ctx.fillStyle = '#AAA';
      ctx.fillText('Asta: Space to attack | Transform (T): Black Form', canvas.width / 2, 450);
      ctx.fillText('Noelle: Space = Water Ball | E = Shield | Q = Sea Dragon', canvas.width / 2, 480);
    }

    function drawGame() {
      // Draw player
      if (isTransformed && selectedCharacter === 'asta') {
        // Black Asta form
        ctx.fillStyle = '#000000';
        ctx.fillRect(player.x, player.y, player.width, player.height);
        ctx.fillStyle = '#FF0000';
        ctx.fillRect(player.x + 5, player.y + 5, player.width - 10, player.height - 10);
      } else if (isTransformed && selectedCharacter === 'noelle') {
        // Transformed Noelle
        ctx.fillStyle = '#00BFFF';
        ctx.fillRect(player.x, player.y, player.width, player.height);
        ctx.fillStyle = '#4169E1';
        ctx.fillRect(player.x + 5, player.y + 5, player.width - 10, player.height - 10);
      } else {
        ctx.fillStyle = selectedCharacter === 'asta' ? '#4169E1' : '#87CEEB';
        ctx.fillRect(player.x, player.y, player.width, player.height);
      }

      // Draw shield
      if (shieldActive) {
        ctx.strokeStyle = '#00BFFF';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(player.x + player.width / 2, player.y + player.height / 2, 40, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Draw Licht
      ctx.fillStyle = '#FFD700';
      ctx.fillRect(licht.x, licht.y, licht.width, licht.height);
      ctx.fillStyle = '#FFF';
      ctx.fillRect(licht.x + 20, licht.y + 20, 20, 20);

      // Draw clones
      clones.forEach(clone => {
        ctx.fillStyle = '#FFD700';
        ctx.globalAlpha = 0.6;
        ctx.fillRect(clone.x, clone.y, clone.width, clone.height);
        ctx.globalAlpha = 1;
      });

      // Draw projectiles
      projectiles.forEach(proj => {
        ctx.fillStyle = '#FF6347';
        ctx.fillRect(proj.x, proj.y, proj.width, proj.height);
      });

      // Draw player attacks
      playerAttacks.forEach(attack => {
        ctx.fillStyle = attack.color;
        if (attack.type === 'dragon') {
          ctx.fillRect(attack.x, attack.y, attack.width, attack.height);
          ctx.fillStyle = '#FFF';
          ctx.fillRect(attack.x + 10, attack.y + 15, 15, 20);
        } else {
          ctx.beginPath();
          ctx.arc(attack.x + attack.width / 2, attack.y + attack.height / 2, attack.width / 2, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      // Draw particles
      particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 30;
        ctx.fillRect(p.x, p.y, p.size, p.size);
        ctx.globalAlpha = 1;
      });

      // Draw UI
      drawUI();

      // Check win/lose
      if (licht.health <= 0) {
        gameState = 'victory';
      }
      if (player.health <= 0) {
        gameState = 'defeat';
      }
    }

    function drawUI() {
      // Player health
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(10, 10, 214, 34);
      ctx.fillStyle = '#32CD32';
      ctx.fillRect(12, 12, (player.health / player.maxHealth) * 210, 30);
      ctx.strokeStyle = '#FFF';
      ctx.lineWidth = 2;
      ctx.strokeRect(12, 12, 210, 30);
      ctx.fillStyle = '#FFF';
      ctx.font = 'bold 16px Arial';
      ctx.fillText(`HP: ${Math.max(0, Math.floor(player.health))}`, 20, 33);

      // Licht health
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(canvas.width - 224, 10, 214, 34);
      ctx.fillStyle = '#FF4500';
      ctx.fillRect(canvas.width - 222, 12, (licht.health / licht.maxHealth) * 210, 30);
      ctx.strokeStyle = '#FFF';
      ctx.strokeRect(canvas.width - 222, 12, 210, 30);
      ctx.fillStyle = '#FFF';
      ctx.fillText(`Licht: ${Math.max(0, Math.floor(licht.health))}`, canvas.width - 210, 33);

      // Phase indicator
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 20px Arial';
      ctx.fillText(`Phase ${licht.phase}`, canvas.width / 2 - 40, 30);

      // Transformation meter
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(10, 54, 214, 34);
      
      if (isTransformed) {
        // Show ACTIVE with countdown
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(12, 56, 210, 30);
        ctx.fillStyle = '#000';
        ctx.font = 'bold 16px Arial';
        ctx.fillText('ACTIVE', 20, 77);
        ctx.fillText(`${transformTimeLeft.toFixed(1)}s`, 150, 77);
      } else {
        // Show meter filling
        const meterPercent = (transformMeter / 600) * 210;
        ctx.fillStyle = transformMeter >= 600 ? '#FFD700' : '#9370DB';
        ctx.fillRect(12, 56, meterPercent, 30);
        ctx.strokeStyle = '#FFF';
        ctx.strokeRect(12, 56, 210, 30);
        ctx.fillStyle = '#FFF';
        ctx.font = 'bold 14px Arial';
        const meterText = hasUsedTransform ? 'Transform: USED' : `Transform: ${Math.floor(transformMeter)}/600`;
        ctx.fillText(meterText, 20, 77);
      }

      // Cooldown indicators for Noelle
      if (selectedCharacter === 'noelle') {
        ctx.font = '14px Arial';
        ctx.fillStyle = '#FFF';
        if (shieldActive) {
          ctx.fillText(`Shield: ${(shieldCooldown / 60).toFixed(1)}s`, 10, 110);
        } else if (shieldCooldown > 0) {
          ctx.fillText(`Shield CD: ${(shieldCooldown / 60).toFixed(1)}s`, 10, 110);
        } else {
          ctx.fillText('Shield: Ready (E)', 10, 110);
        }
        
        if (seaDragonCooldown > 0) {
          ctx.fillText(`Dragon CD: ${(seaDragonCooldown / 60).toFixed(1)}s`, 10, 130);
        } else if (!shieldActive) {
          ctx.fillText('Dragon: Ready (Q)', 10, 130);
        } else {
          ctx.fillText('Dragon: Shield Active', 10, 130);
        }
      }
    }

    function drawVictory() {
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 64px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('VICTORY!', canvas.width / 2, canvas.height / 2);
      
      ctx.font = '24px Arial';
      ctx.fillStyle = '#FFF';
      ctx.fillText('You defeated Licht!', canvas.width / 2, canvas.height / 2 + 60);
      ctx.fillText('Refresh to play again', canvas.width / 2, canvas.height / 2 + 100);
    }

    function drawDefeat() {
      ctx.fillStyle = '#FF4500';
      ctx.font = 'bold 64px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('DEFEAT', canvas.width / 2, canvas.height / 2);
      
      ctx.font = '24px Arial';
      ctx.fillStyle = '#FFF';
      ctx.fillText('You were defeated...', canvas.width / 2, canvas.height / 2 + 60);
      ctx.fillText('Refresh to try again', canvas.width / 2, canvas.height / 2 + 100);
    }

    function gameLoop() {
      if (gameState === 'playing') {
        updatePlayer();
        updateLicht();
        updateClones();
        updateProjectiles();
        updatePlayerAttacks();
        updateParticles();
      }
      
      draw();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
